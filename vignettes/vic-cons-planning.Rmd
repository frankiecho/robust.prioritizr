---
title: "Example: Robust Conservation Planning in Victoria, Australia"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{c. vic-cons-planning}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width=8, 
  fig.height=6,
  fig.retina = TRUE
)
```

```{r, include = FALSE}
# define dummy variables so that vignette passes package checks
# TODO
```

```{r, include = FALSE}
# define variables for vignette figures and code execution
h <- 3.5
w <- 3.5
is_check <-
  ("CheckExEnv" %in% search()) ||
  any(c("_R_CHECK_TIMINGS_", "_R_CHECK_LICENSE_") %in% names(Sys.getenv())) ||
  !identical(Sys.getenv("MY_UNIVERSE"), "") ||
  any(c("CI", "GITHUB_ACTIONS", "GITHUB_SHA") %in% names(Sys.getenv()))
knitr::opts_chunk$set(
  fig.align = "center",
  eval = !is_check,
  purl = !is_check,
  R.options = list(width = 80)
)
```

```{r, include = FALSE}
# set up print method
print <- function(x, ...) {
  if (!interactive() && inherits(x, "ConservationProblem")) {
    prioritizr::knit_print.ConservationProblem(x)
  } else if (!interactive() && inherits(x, "OptimizationProblem")) {
    prioritizr::knit_print.OptimizationProblem(x)
  } else {
    base::print(x)
  }
}
```

```{r setup, include = FALSE}
library(prioritizr)
library(robust.prioritizr)
library(terra)
library(dplyr)
library(tibble)
library(stringr)
library(knitr)
library(ggplot2)
library(tidyr)
```

# Planning for Threatened Species in Victoria

This example demonstrates how to use `robust.prioritizr` for systematic conservation planning in Victoria, Australia. We will use data for future species occurrence projections, conservation costs, and existing protected areas.

First, we load the datasets, which are bundled with the package. The primary data is a packed `terra` SpatRaster object, which we will unwrap to access the individual raster layers.

```{r}
data("vic_cmip6")
species <- unwrap(vic_cmip6$species)
cost <- unwrap(vic_cmip6$cost)
pa <- unwrap(vic_cmip6$pa)
species_details <- vic_cmip6$species_details
study_area <- unwrap(vic_cmip6$study_area)
rm(vic_cmip6)
```

The data package contains the following datasets:

-   **Species occurrence (`species`):** Projections for 18 threatened species across four CMIP6 climate scenarios (e.g., SSP1-RCP2.6, SSP5-RCP8.5) and five time periods (1990-2090). Derived from Archibald et al. (2024).

-   **Species details (`species_details`):** A table linking the raster layer names to their corresponding species, climate scenarios, and timesteps.

-   **Conservation cost (`cost`):** A proxy for conservation cost based on the 2013 Human Footprint Index.

-   **Protected areas (`pa`):** The location of current protected areas.

-   **Study area (`study_area`):** A boundary for the state of Victoria.

We can visualize the projected occurrence of the brush-tailed rock-wallaby (*Petrogale penicillata*), a critically endangered species in Victoria. The figure below shows that the wallaby's suitable habitat is projected to shrink considerably under a high-emissions climate scenario.

```{r}
wallaby <- species_details %>%
  filter(species == 'Petrogale_penicillata' & timestep >= 2050)
wallaby_ids <- pull(wallaby, id)
wallaby_maps <- species[[wallaby_ids]]
names(wallaby_maps) <- paste0(pull(wallaby, scenario), ": ", pull(wallaby, timestep))

plot(wallaby_maps, axes = F, maxcell = 1e4, , fun= \() lines(study_area))
```

As the figure illustrates, the projected distribution of species can change dramatically depending on the time period and climate scenario. `robust.prioritizr` is designed to handle this challenge by integrating these different scenarios, ensuring the final conservation plan meets its targets regardless of which future unfolds.

# Robust Conservation Planning

## Feature Groupings

A key concept in `robust.prioritizr` is the `groups` argument. In a standard `prioritizr` problem, each feature is a single data layer. In contrast, `robust.prioritizr` uses **multiple** layers to represent a single feature, where each layer corresponds to a different scenario (e.g., a climate projection or time-step).

The `groups` argument is a character vector that tells the solver which layers belong to the same feature. This allows the problem to apply a single, shared target to all scenarios for that feature. For this example, the group for each layer is simply the species name.

```{r}
groups <- species_details$species
head(groups)
```

## Setting a Feasible Target

When using a robust minimum set objective, it is crucial to set a target that is achievable across all scenarios. If a target for a species is higher than its total predicted occurrence in even one scenario, the problem will be infeasible.

`robust.prioritizr` enforces that features have the same target within each group, ensuring that the same target is met across all realizations of the data. This means that if targets are not consistent within the same group, it will override targets specified by the user. The package has the following internal behaviour for absolute, relative and manual targets:

-   Absolute targets: ensures that the target in absolute terms is met across all climates and time-steps

-   Relative targets: first, it calculates the "best-case" feature values in each group, by finding the realization in the groiup that has the highest summed feature value. Then, it calculates the relative target in absolute terms by multiplying the user-supplied target (e.g., 20%) in `add_relative_targets` with the "best-case" feature value. This ensures that the feature representation of the solution meets the relative target even in a "good" realization where the feature is abundant in the study area

-   Manual targets: manual targets must be specified for each realization of each feature. If different targets are specified for features in the same group, `robust.prioritizr` will take the maximum of the target. This means that manual targets should be consistent within the same group, otherwise it would yield unexpected behavior (particularly if the "sense" is altered to "\<=").

To figure out what useful relative targets to use, we can calculate the worst-case and best-case feature representations for each species by using the `global` function in `terra`, and then summarise the best and worst-case values using `dplyr`. We can also find out what is the maximum relative target we can use in the problem to ensure that our problem is still feasible.

```{r}
global_sum_species <- global(species, fun = 'sum', na.rm = TRUE) %>%
  as.data.frame() %>%
  rownames_to_column("name")
worst_case_occurrence <- species_details %>%
  select(-any_of("sum")) %>%
  left_join(global_sum_species, by = "name") %>%
  group_by(species) %>%
  summarise(worst_case = min(sum),
            pct_20 = quantile(sum, 0.2),
            cvar = mean(sum[sum < quantile(sum, 0.1)]),
            best_case = max(sum),
            max_relative_target = round(worst_case/ best_case, 4),
            pct20_relative_target = round(pct_20/ best_case, 4),
            worst_case_scenario = proj[which.min(sum)]) %>%
  arrange(max_relative_target) 
worst_case_occurrence %>%
  head()# %>%
  #kable()
```

This shows that if we are interested in a fully robust solution, the maximum relative target that is achievable for this problem would be 0.0022, as in the worst-case scenario, the Snowy Mountains skink (Liopholis guthega) is only represented in 1 5km grid cell, out of 452 grid cells in its best-case scenario. This means that even if all the planning units are selected for conservation, in the worst-case high-emissions climate scenario the Snowy Mountains skink will only be represented in a very small area.

In this piece of code here we also lay the groundwork for alternative relative targets we can use by computing the 20th percentile of maximum species representation achievable. If we let the solution fall below the target for up to 20% of the outcomes, the maximum relative target that is achievable for the Snown Mountains skink would be near 0.075.

After solving the initial problem, we will progress to explore how to increase the relative targets we use by relaxing the robustness of the problem, such that the representation of other species in the data can be increased.

## Solving the Robust Problem

The workflow for a robust problem is similar to `prioritizr`, but with the addition of robust-specific functions. Here is a breakdown of the problem construction:

-   `problem()`: Defines the planning units (cost) and features (species scenarios).
-   `add_absolute_targets()`: Sets the conservation target (at least 1 cell).
-   `add_constant_robust_constraints()`: Specifies the `groups` that link scenarios to features.
-   `add_robust_min_set_objective()`: The robust version of the minimum set objective.
-   `add_locked_in_constraints()`: Locks in existing protected areas.
-   `add_default_solver()`: Selects the solver to use.

```{r}
rt <- 0.0022
rpv1 <- problem(cost, species) %>%
  add_relative_targets(rt) %>%
  robust.prioritizr::add_constant_robust_constraints(groups = groups) %>%
  robust.prioritizr::add_robust_min_set_objective() %>%
  add_locked_in_constraints(pa) %>%
  add_default_solver(verbose = F)

rsv1 <- solve(rpv1, force = TRUE)

plot(rsv1, axes = F)
plot(study_area, add = TRUE)
title("Robust Solution (Target = 1%)")

```

The problem solves as expected.

> **Note on Presolve Warnings:** You may see a warning from the solver about failing "presolve" checks. This is expected. The robust formulation uses a structure that is different from standard `prioritizr` problems. Using `force = TRUE` allows the solver to proceed. We are working on updates to make this integration seamless.

We can now verify that the target was met for all species across all scenarios and time-steps.

```{r}
feature_rep_r <- global(species * rsv1, fun = 'sum', na.rm = T) %>%
  as.data.frame() %>%
  rownames_to_column('name')
worst_case_occurrence$rt <- rt*worst_case_occurrence$best_case
species_details %>%
  select(-any_of(contains('sum'))) %>%
  arrange(species, scenario, timestep) %>%
  left_join(feature_rep_r, by = "name") %>%
  mutate(species_scenario = paste(species, scenario)) %>%
  ggplot(aes(x = timestep, y = sum, color = scenario, group = species_scenario)) +
  facet_wrap(vars(species), scales = "free_y") +
  geom_line() +
  theme_bw() +
  geom_hline(data = worst_case_occurrence, aes(yintercept = rt)) +
  labs(x = "Time-step", y = "Representation (number of cells)") +
  coord_cartesian(xlim = c(2030, 2090)) +
  theme(panel.grid = element_blank(),
        legend.position = 'bottom')
```

The plot shows the target is met in all cases. However, since the target was very low, there is clearly room to protect more habitat for many species. This motivates exploring solutions with higher targets, potentially by relaxing the robustness constraints.

## Relaxing robustness to increase the target

As the previous example shows, enforcing targets to be held robustly across all scenarios and timesteps can be unrealistic. This limits the maximum feasible target we can adopt for the planning solution. This also means that there are lots of room to improve the representation of other species. If the robustness of the target is relaxed – say instead of having to hold across all realizations, it only needs to hold at a certain probability – then there will be a lot more room to increase the target.

Users can control the robustness of the solution through the `conf_level` parameter in `add_*_robust_constraints`, which specifies the proportion of the constraints that must be met in each group for the solution to be considered feasible. In this case, specifying 80% means that out of the 17 historic and future climate projections, the solution needs to meet the target in at least 13 (17 \times 0.8) climate projections/ time-steps. By relaxing this target, we can pursue much more ambitious relative targets (0.07 protection), while ensuring that the solution is robust under most climate projections and time-steps.

```{r}
rt2 <- 0.07
rpv2 <- problem(cost, species) %>%
  add_relative_targets(rt2) %>%
  robust.prioritizr::add_constant_robust_constraints(groups = groups,
                                                     conf_level = 0.8) %>%
  add_locked_in_constraints(pa) %>%
  robust.prioritizr::add_robust_min_set_objective(method = "Chance") %>%
  add_default_solver(verbose = F)

rsv2 <- solve(rpv2, force = TRUE)

rs <- c(rsv1, rsv2, rsv1-pa, rsv2-pa)
names(rs) <- c("Robust (1% target)", "Partially Robust (7% target)", "New PA (Robust 1%)", "New PA (Partially Robust 7%)")
plot(rs, axes = F, fun = \() lines(study_area), type = 'continuous', range = c(0,1))
```

```{r}
feature_rep_r2 <- global(species * rsv2, fun = 'sum', na.rm = T) %>%
  as.data.frame() %>%
  rownames_to_column('name')
worst_case_occurrence$rt2 <- rt2*worst_case_occurrence$best_case
rsv2_representation <- species_details %>%
  select(-any_of(contains('sum'))) %>%
  arrange(species, scenario, timestep) %>%
  left_join(feature_rep_r2, by = "name") %>%
  mutate(species_scenario = paste(species, scenario)) 
rsv2_representation %>%
  ggplot(aes(x = timestep, y = sum, color = scenario, group = species_scenario)) +
  facet_wrap(vars(species), scales = "free_y") +
  geom_hline(data = worst_case_occurrence, aes(yintercept = rt2), linetype = 2) +
  geom_line() +
  theme_bw() +
  labs(x = "Time-step", y = "Representation (number of cells)") +
  coord_cartesian(xlim = c(2030, 2090)) +
  theme(panel.grid = element_blank(),
        legend.position = 'bottom')
```

We can also do our due-diligence and verify that indeed the relative targets are not breached for more than 20% of the climate projections/ time-steps. We can validate that the planning solution limits the times the target is breached to up to 18%, for even the most challenging species to conserve, such as the Snowy Mountains skink.

```{r}
rsv2_representation %>%
  left_join(worst_case_occurrence, by = 'species') %>%
  group_by(species) %>%
  summarise(
    violation_pct = round(mean(sum < rt2), 3)
  ) %>%
  arrange(-violation_pct) %>%
  head()
```

## Comparison with a Non-Robust Solution

For comparison, we solve a standard `prioritizr` problem using only the historical baseline data and a higher target. We apply the same 7% target to the problem, but only solve this 

```{r}
is_historic_baseline <- species_details %>%
  filter(scenario == 'historic_baseline') %>%
  pull(id)

species_hb <- species[[is_historic_baseline]]

pv1 <- problem(cost, species_hb) %>%
  add_relative_targets(0.07) %>%
  add_min_set_objective() %>%
  add_locked_in_constraints(pa) %>%
  add_default_solver(verbose = F)

cv1 <- compile(pv1)
sv1 <- solve(pv1)
soln_v1 <- c(sv1, rsv2, sv1-pa, rsv2-pa)
names(soln_v1) <- c("Non-robust", "Robust", "New PA (Non-robust)", "New PA (Robust)")
plot(soln_v1, axes = F, fun = \() lines(study_area), type = "continuous", range = c(0,1))
```

While the non-robust solution may appear effective based on historical data, its performance can be evaluated across the future scenarios. For instance, we can check the representation of the Tasmanian devil (*Sarcophilus harrisii*) and compare it against the partially robust solution. We observe that the number of climate projections where the Tasmanian devil representation falls below the target is reduced.

```{r}
selected_species <- species_details %>%
  filter(species == 'Sarcophilus_harrisii') %>%
  arrange(scenario, timestep)
feature_rep_nr <- global(species[[selected_species$id]] * sv1, fun = 'sum', na.rm = T) %>%
  rownames_to_column("name") %>%
  rename(non_robust = sum)
feature_rep_r <- global(species[[selected_species$id]] * rsv2, fun = 'sum', na.rm = T) %>%
  rownames_to_column("name") %>%
  rename(robust = sum)

species_details %>%
  right_join(feature_rep_nr, by = 'name') %>%
  right_join(feature_rep_r, by = 'name') %>%
  pivot_longer(c('non_robust', 'robust'), names_to = 'solution') %>%
  mutate(solution = factor(solution, c('non_robust', 'robust'), c("Non-robust", "Partially Robust"))) %>%
  left_join(worst_case_occurrence, by = 'species') %>%
  mutate(species_scenario = paste(species, scenario)) %>%
  filter(timestep > 1990) %>%
  ggplot(aes(x = timestep, y = value, color = scenario, group = species_scenario)) +
  facet_wrap(vars(solution)) +
  geom_hline(data = worst_case_occurrence %>% filter(species == 'Sarcophilus_harrisii'), aes(yintercept = rt2), linetype = 2) +
  geom_point() +
  geom_line() +
  theme_bw() +
  labs(x = "Time-step", y = "Representation (number of cells)") +
  coord_cartesian(xlim = c(2030, 2090)) +
  theme(panel.grid = element_blank(),
        legend.position = 'bottom')
```

